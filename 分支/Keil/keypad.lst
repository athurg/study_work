C51 COMPILER V7.06   KEYPAD                                                                10/14/2008 14:15:57 PAGE 1   


C51 COMPILER V7.06, COMPILATION OF MODULE KEYPAD
OBJECT MODULE PLACED IN keypad.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE keypad.c BROWSE DEBUG OBJECTEXTEND

stmt level    source

   1          #include "keypad.h"
   2          
   3          
   4          char key_make(char key)
   5          {
   6   1      /******************************
   7   1      *    键盘值生成函数
   8   1      *
   9   1      *  参数：键盘扫描所得的特征值
  10   1      *  返回：键值或者’B‘(BLANK)
  11   1      *
  12   1      ******************************/
  13   1          char i;
  14   1          struct keypad{char index;char value;};              //键盘键值表结构
  15   1          struct keypad keytable[]={
  16   1              {0xee,1},{0xde,2},{0xbe,3},{0x7e,21},
  17   1              {0xed,6},{0xdd,5},{0xbd,4},{0x7d,22},
  18   1              {0xeb,7},{0xdb,8},{0xbb,9},{0x7b,23},
  19   1              {0xe7,10},{0xd7,0},{0xb7,20},{0x77,24},{0x00,'B'}
  20   1          };
  21   1              /*
  22   1              1       2       3       w
  23   1              6       5       4       f
  24   1              7       8       9       a
  25   1              10      0       c       s
  26   1              */
  27   1          for(i=16;i>=0;i--)
  28   1          {
  29   2              if(keytable[i].index==key)      return keytable[i].value;
  30   2          }
  31   1          return 0x00;
  32   1      }
  33          
  34          char key_scan(void)
  35          {
  36   1      /*
  37   1      *    键盘扫描函数
  38   1      *
  39   1      *    参数:无
  40   1      *    返回:扫描特征值
  41   1      *
  42   1      *    说明:
  43   1      *        行扫描代码(0111,1011,1101,1110)没有任何规律可循，但是将其取反后(1000,0100,0010,0001)可以
  44   1      *    发现，扫描代码是一个偶数数列（8，4，2，1）。
  45   1      *        因此可以通过用偶数数列取反得到行扫描码，然后输出；而且内部使用逐次除2的方式，最后一个扫描
  46   1      *    码生成之后除2恰好为0，可以作为while()退出的条件利用。
  47   1      */
  48   1          char line=0x08;                     //行扫描起始码(00001000B)
  49   1          while(line)
  50   1          {
  51   2              P1=~line;
  52   2              if((P1>>4)!=0x0f) break;
  53   2              line/=2;
  54   2          }
  55   1          line=P1;
C51 COMPILER V7.06   KEYPAD                                                                10/14/2008 14:15:57 PAGE 2   

  56   1          P1=0xf0; //重新初始化P1口，自己的事情自己搞完
  57   1          
  58   1          return line;
  59   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     84    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      35
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
